// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Settings extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Settings entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Settings must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Settings", id.toString(), this);
    }
  }

  static load(id: string): Settings | null {
    return changetype<Settings | null>(store.get("Settings", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get insuranceFund(): Bytes {
    let value = this.get("insuranceFund");
    return value!.toBytes();
  }

  set insuranceFund(value: Bytes) {
    this.set("insuranceFund", Value.fromBytes(value));
  }

  get oracle(): Bytes {
    let value = this.get("oracle");
    return value!.toBytes();
  }

  set oracle(value: Bytes) {
    this.set("oracle", Value.fromBytes(value));
  }

  get treasury(): Bytes {
    let value = this.get("treasury");
    return value!.toBytes();
  }

  set treasury(value: Bytes) {
    this.set("treasury", Value.fromBytes(value));
  }
}

export class DailySnap extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DailySnap entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DailySnap must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DailySnap", id.toString(), this);
    }
  }

  static load(id: string): DailySnap | null {
    return changetype<DailySnap | null>(store.get("DailySnap", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txcount(): i32 {
    let value = this.get("txcount");
    return value!.toI32();
  }

  set txcount(value: i32) {
    this.set("txcount", Value.fromI32(value));
  }

  get activeusers(): i32 {
    let value = this.get("activeusers");
    return value!.toI32();
  }

  set activeusers(value: i32) {
    this.set("activeusers", Value.fromI32(value));
  }
}

export class UniqueUserHash extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UniqueUserHash entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UniqueUserHash must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UniqueUserHash", id.toString(), this);
    }
  }

  static load(id: string): UniqueUserHash | null {
    return changetype<UniqueUserHash | null>(store.get("UniqueUserHash", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class LidoStopped extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoStopped entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoStopped must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoStopped", id.toString(), this);
    }
  }

  static load(id: string): LidoStopped | null {
    return changetype<LidoStopped | null>(store.get("LidoStopped", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }
}

export class LidoResumed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoResumed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoResumed must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoResumed", id.toString(), this);
    }
  }

  static load(id: string): LidoResumed | null {
    return changetype<LidoResumed | null>(store.get("LidoResumed", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }
}

export class LidoTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoTransfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoTransfer", id.toString(), this);
    }
  }

  static load(id: string): LidoTransfer | null {
    return changetype<LidoTransfer | null>(store.get("LidoTransfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get shares(): BigInt | null {
    let value = this.get("shares");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set shares(value: BigInt | null) {
    if (!value) {
      this.unset("shares");
    } else {
      this.set("shares", Value.fromBigInt(<BigInt>value));
    }
  }

  get sharesBeforeDecrease(): BigInt | null {
    let value = this.get("sharesBeforeDecrease");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set sharesBeforeDecrease(value: BigInt | null) {
    if (!value) {
      this.unset("sharesBeforeDecrease");
    } else {
      this.set("sharesBeforeDecrease", Value.fromBigInt(<BigInt>value));
    }
  }

  get sharesAfterDecrease(): BigInt | null {
    let value = this.get("sharesAfterDecrease");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set sharesAfterDecrease(value: BigInt | null) {
    if (!value) {
      this.unset("sharesAfterDecrease");
    } else {
      this.set("sharesAfterDecrease", Value.fromBigInt(<BigInt>value));
    }
  }

  get sharesBeforeIncrease(): BigInt | null {
    let value = this.get("sharesBeforeIncrease");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set sharesBeforeIncrease(value: BigInt | null) {
    if (!value) {
      this.unset("sharesBeforeIncrease");
    } else {
      this.set("sharesBeforeIncrease", Value.fromBigInt(<BigInt>value));
    }
  }

  get sharesAfterIncrease(): BigInt | null {
    let value = this.get("sharesAfterIncrease");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set sharesAfterIncrease(value: BigInt | null) {
    if (!value) {
      this.unset("sharesAfterIncrease");
    } else {
      this.set("sharesAfterIncrease", Value.fromBigInt(<BigInt>value));
    }
  }

  get mintWithoutSubmission(): boolean {
    let value = this.get("mintWithoutSubmission");
    return value!.toBoolean();
  }

  set mintWithoutSubmission(value: boolean) {
    this.set("mintWithoutSubmission", Value.fromBoolean(value));
  }

  get totalPooledEther(): BigInt {
    let value = this.get("totalPooledEther");
    return value!.toBigInt();
  }

  set totalPooledEther(value: BigInt) {
    this.set("totalPooledEther", Value.fromBigInt(value));
  }

  get totalShares(): BigInt {
    let value = this.get("totalShares");
    return value!.toBigInt();
  }

  set totalShares(value: BigInt) {
    this.set("totalShares", Value.fromBigInt(value));
  }

  get balanceAfterDecrease(): BigInt | null {
    let value = this.get("balanceAfterDecrease");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set balanceAfterDecrease(value: BigInt | null) {
    if (!value) {
      this.unset("balanceAfterDecrease");
    } else {
      this.set("balanceAfterDecrease", Value.fromBigInt(<BigInt>value));
    }
  }

  get balanceAfterIncrease(): BigInt | null {
    let value = this.get("balanceAfterIncrease");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set balanceAfterIncrease(value: BigInt | null) {
    if (!value) {
      this.unset("balanceAfterIncrease");
    } else {
      this.set("balanceAfterIncrease", Value.fromBigInt(<BigInt>value));
    }
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get transactionIndex(): BigInt {
    let value = this.get("transactionIndex");
    return value!.toBigInt();
  }

  set transactionIndex(value: BigInt) {
    this.set("transactionIndex", Value.fromBigInt(value));
  }

  get logIndex(): BigInt {
    let value = this.get("logIndex");
    return value!.toBigInt();
  }

  set logIndex(value: BigInt) {
    this.set("logIndex", Value.fromBigInt(value));
  }

  get transactionLogIndex(): BigInt {
    let value = this.get("transactionLogIndex");
    return value!.toBigInt();
  }

  set transactionLogIndex(value: BigInt) {
    this.set("transactionLogIndex", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    return value!.toString();
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }
}

export class LidoApproval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoApproval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoApproval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoApproval", id.toString(), this);
    }
  }

  static load(id: string): LidoApproval | null {
    return changetype<LidoApproval | null>(store.get("LidoApproval", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class LidoFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoFee must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoFee", id.toString(), this);
    }
  }

  static load(id: string): LidoFee | null {
    return changetype<LidoFee | null>(store.get("LidoFee", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get feeBasisPoints(): i32 {
    let value = this.get("feeBasisPoints");
    return value!.toI32();
  }

  set feeBasisPoints(value: i32) {
    this.set("feeBasisPoints", Value.fromI32(value));
  }
}

export class LidoFeeDistribution extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoFeeDistribution entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoFeeDistribution must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoFeeDistribution", id.toString(), this);
    }
  }

  static load(id: string): LidoFeeDistribution | null {
    return changetype<LidoFeeDistribution | null>(
      store.get("LidoFeeDistribution", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get treasuryFeeBasisPoints(): i32 {
    let value = this.get("treasuryFeeBasisPoints");
    return value!.toI32();
  }

  set treasuryFeeBasisPoints(value: i32) {
    this.set("treasuryFeeBasisPoints", Value.fromI32(value));
  }

  get insuranceFeeBasisPoints(): i32 {
    let value = this.get("insuranceFeeBasisPoints");
    return value!.toI32();
  }

  set insuranceFeeBasisPoints(value: i32) {
    this.set("insuranceFeeBasisPoints", Value.fromI32(value));
  }

  get operatorsFeeBasisPoints(): i32 {
    let value = this.get("operatorsFeeBasisPoints");
    return value!.toI32();
  }

  set operatorsFeeBasisPoints(value: i32) {
    this.set("operatorsFeeBasisPoints", Value.fromI32(value));
  }
}

export class LidoWithdrawalCredential extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save LidoWithdrawalCredential entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type LidoWithdrawalCredential must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoWithdrawalCredential", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): LidoWithdrawalCredential | null {
    return changetype<LidoWithdrawalCredential | null>(
      store.get("LidoWithdrawalCredential", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get withdrawalCredentials(): Bytes {
    let value = this.get("withdrawalCredentials");
    return value!.toBytes();
  }

  set withdrawalCredentials(value: Bytes) {
    this.set("withdrawalCredentials", Value.fromBytes(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }
}

export class LidoSubmission extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoSubmission entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoSubmission must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoSubmission", id.toString(), this);
    }
  }

  static load(id: string): LidoSubmission | null {
    return changetype<LidoSubmission | null>(store.get("LidoSubmission", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get referral(): Bytes {
    let value = this.get("referral");
    return value!.toBytes();
  }

  set referral(value: Bytes) {
    this.set("referral", Value.fromBytes(value));
  }

  get shares(): BigInt {
    let value = this.get("shares");
    return value!.toBigInt();
  }

  set shares(value: BigInt) {
    this.set("shares", Value.fromBigInt(value));
  }

  get sharesBefore(): BigInt {
    let value = this.get("sharesBefore");
    return value!.toBigInt();
  }

  set sharesBefore(value: BigInt) {
    this.set("sharesBefore", Value.fromBigInt(value));
  }

  get sharesAfter(): BigInt {
    let value = this.get("sharesAfter");
    return value!.toBigInt();
  }

  set sharesAfter(value: BigInt) {
    this.set("sharesAfter", Value.fromBigInt(value));
  }

  get totalPooledEtherBefore(): BigInt {
    let value = this.get("totalPooledEtherBefore");
    return value!.toBigInt();
  }

  set totalPooledEtherBefore(value: BigInt) {
    this.set("totalPooledEtherBefore", Value.fromBigInt(value));
  }

  get totalPooledEtherAfter(): BigInt {
    let value = this.get("totalPooledEtherAfter");
    return value!.toBigInt();
  }

  set totalPooledEtherAfter(value: BigInt) {
    this.set("totalPooledEtherAfter", Value.fromBigInt(value));
  }

  get totalSharesBefore(): BigInt {
    let value = this.get("totalSharesBefore");
    return value!.toBigInt();
  }

  set totalSharesBefore(value: BigInt) {
    this.set("totalSharesBefore", Value.fromBigInt(value));
  }

  get totalSharesAfter(): BigInt {
    let value = this.get("totalSharesAfter");
    return value!.toBigInt();
  }

  set totalSharesAfter(value: BigInt) {
    this.set("totalSharesAfter", Value.fromBigInt(value));
  }

  get balanceAfter(): BigInt {
    let value = this.get("balanceAfter");
    return value!.toBigInt();
  }

  set balanceAfter(value: BigInt) {
    this.set("balanceAfter", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get transactionIndex(): BigInt {
    let value = this.get("transactionIndex");
    return value!.toBigInt();
  }

  set transactionIndex(value: BigInt) {
    this.set("transactionIndex", Value.fromBigInt(value));
  }

  get logIndex(): BigInt {
    let value = this.get("logIndex");
    return value!.toBigInt();
  }

  set logIndex(value: BigInt) {
    this.set("logIndex", Value.fromBigInt(value));
  }

  get transactionLogIndex(): BigInt {
    let value = this.get("transactionLogIndex");
    return value!.toBigInt();
  }

  set transactionLogIndex(value: BigInt) {
    this.set("transactionLogIndex", Value.fromBigInt(value));
  }
}

export class LidoUnbuffered extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoUnbuffered entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoUnbuffered must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoUnbuffered", id.toString(), this);
    }
  }

  static load(id: string): LidoUnbuffered | null {
    return changetype<LidoUnbuffered | null>(store.get("LidoUnbuffered", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class LidoWithdrawal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LidoWithdrawal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LidoWithdrawal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LidoWithdrawal", id.toString(), this);
    }
  }

  static load(id: string): LidoWithdrawal | null {
    return changetype<LidoWithdrawal | null>(store.get("LidoWithdrawal", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get tokenAmount(): BigInt {
    let value = this.get("tokenAmount");
    return value!.toBigInt();
  }

  set tokenAmount(value: BigInt) {
    this.set("tokenAmount", Value.fromBigInt(value));
  }

  get sentFromBuffer(): BigInt {
    let value = this.get("sentFromBuffer");
    return value!.toBigInt();
  }

  set sentFromBuffer(value: BigInt) {
    this.set("sentFromBuffer", Value.fromBigInt(value));
  }

  get pubkeyHash(): Bytes {
    let value = this.get("pubkeyHash");
    return value!.toBytes();
  }

  set pubkeyHash(value: Bytes) {
    this.set("pubkeyHash", Value.fromBytes(value));
  }

  get etherAmount(): BigInt {
    let value = this.get("etherAmount");
    return value!.toBigInt();
  }

  set etherAmount(value: BigInt) {
    this.set("etherAmount", Value.fromBigInt(value));
  }
}

export class NodeOperatorFees extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NodeOperatorFees entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NodeOperatorFees must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NodeOperatorFees", id.toString(), this);
    }
  }

  static load(id: string): NodeOperatorFees | null {
    return changetype<NodeOperatorFees | null>(
      store.get("NodeOperatorFees", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalReward(): Bytes {
    let value = this.get("totalReward");
    return value!.toBytes();
  }

  set totalReward(value: Bytes) {
    this.set("totalReward", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }
}

export class NodeOperatorsShares extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NodeOperatorsShares entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NodeOperatorsShares must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NodeOperatorsShares", id.toString(), this);
    }
  }

  static load(id: string): NodeOperatorsShares | null {
    return changetype<NodeOperatorsShares | null>(
      store.get("NodeOperatorsShares", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalReward(): Bytes {
    let value = this.get("totalReward");
    return value!.toBytes();
  }

  set totalReward(value: Bytes) {
    this.set("totalReward", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get shares(): BigInt {
    let value = this.get("shares");
    return value!.toBigInt();
  }

  set shares(value: BigInt) {
    this.set("shares", Value.fromBigInt(value));
  }
}

export class Totals extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Totals entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Totals must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Totals", id.toString(), this);
    }
  }

  static load(id: string): Totals | null {
    return changetype<Totals | null>(store.get("Totals", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalPooledEther(): BigInt {
    let value = this.get("totalPooledEther");
    return value!.toBigInt();
  }

  set totalPooledEther(value: BigInt) {
    this.set("totalPooledEther", Value.fromBigInt(value));
  }

  get totalShares(): BigInt {
    let value = this.get("totalShares");
    return value!.toBigInt();
  }

  set totalShares(value: BigInt) {
    this.set("totalShares", Value.fromBigInt(value));
  }
}

export class Stats extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Stats entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Stats must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Stats", id.toString(), this);
    }
  }

  static load(id: string): Stats | null {
    return changetype<Stats | null>(store.get("Stats", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get uniqueHolders(): BigInt | null {
    let value = this.get("uniqueHolders");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set uniqueHolders(value: BigInt | null) {
    if (!value) {
      this.unset("uniqueHolders");
    } else {
      this.set("uniqueHolders", Value.fromBigInt(<BigInt>value));
    }
  }

  get uniqueAnytimeHolders(): BigInt | null {
    let value = this.get("uniqueAnytimeHolders");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set uniqueAnytimeHolders(value: BigInt | null) {
    if (!value) {
      this.unset("uniqueAnytimeHolders");
    } else {
      this.set("uniqueAnytimeHolders", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class Shares extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Shares entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Shares must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Shares", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Shares | null {
    return changetype<Shares | null>(store.get("Shares", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get shares(): BigInt {
    let value = this.get("shares");
    return value!.toBigInt();
  }

  set shares(value: BigInt) {
    this.set("shares", Value.fromBigInt(value));
  }
}

export class Holder extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Holder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Holder must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Holder", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Holder | null {
    return changetype<Holder | null>(store.get("Holder", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }
}

export class CurrentFees extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CurrentFees entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type CurrentFees must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CurrentFees", id.toString(), this);
    }
  }

  static load(id: string): CurrentFees | null {
    return changetype<CurrentFees | null>(store.get("CurrentFees", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get feeBasisPoints(): BigInt | null {
    let value = this.get("feeBasisPoints");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set feeBasisPoints(value: BigInt | null) {
    if (!value) {
      this.unset("feeBasisPoints");
    } else {
      this.set("feeBasisPoints", Value.fromBigInt(<BigInt>value));
    }
  }

  get treasuryFeeBasisPoints(): BigInt | null {
    let value = this.get("treasuryFeeBasisPoints");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set treasuryFeeBasisPoints(value: BigInt | null) {
    if (!value) {
      this.unset("treasuryFeeBasisPoints");
    } else {
      this.set("treasuryFeeBasisPoints", Value.fromBigInt(<BigInt>value));
    }
  }

  get insuranceFeeBasisPoints(): BigInt | null {
    let value = this.get("insuranceFeeBasisPoints");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set insuranceFeeBasisPoints(value: BigInt | null) {
    if (!value) {
      this.unset("insuranceFeeBasisPoints");
    } else {
      this.set("insuranceFeeBasisPoints", Value.fromBigInt(<BigInt>value));
    }
  }

  get operatorsFeeBasisPoints(): BigInt | null {
    let value = this.get("operatorsFeeBasisPoints");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set operatorsFeeBasisPoints(value: BigInt | null) {
    if (!value) {
      this.unset("operatorsFeeBasisPoints");
    } else {
      this.set("operatorsFeeBasisPoints", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class ELRewardsVaultSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ELRewardsVaultSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ELRewardsVaultSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ELRewardsVaultSet", id.toString(), this);
    }
  }

  static load(id: string): ELRewardsVaultSet | null {
    return changetype<ELRewardsVaultSet | null>(
      store.get("ELRewardsVaultSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get executionLayerRewardsVault(): Bytes {
    let value = this.get("executionLayerRewardsVault");
    return value!.toBytes();
  }

  set executionLayerRewardsVault(value: Bytes) {
    this.set("executionLayerRewardsVault", Value.fromBytes(value));
  }
}

export class ELRewardsWithdrawalLimitSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ELRewardsWithdrawalLimitSet entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ELRewardsWithdrawalLimitSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ELRewardsWithdrawalLimitSet", id.toString(), this);
    }
  }

  static load(id: string): ELRewardsWithdrawalLimitSet | null {
    return changetype<ELRewardsWithdrawalLimitSet | null>(
      store.get("ELRewardsWithdrawalLimitSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get limitPoints(): BigInt {
    let value = this.get("limitPoints");
    return value!.toBigInt();
  }

  set limitPoints(value: BigInt) {
    this.set("limitPoints", Value.fromBigInt(value));
  }
}

export class ProtocolContactsSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProtocolContactsSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProtocolContactsSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProtocolContactsSet", id.toString(), this);
    }
  }

  static load(id: string): ProtocolContactsSet | null {
    return changetype<ProtocolContactsSet | null>(
      store.get("ProtocolContactsSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get insuranceFund(): Bytes {
    let value = this.get("insuranceFund");
    return value!.toBytes();
  }

  set insuranceFund(value: Bytes) {
    this.set("insuranceFund", Value.fromBytes(value));
  }

  get oracle(): Bytes {
    let value = this.get("oracle");
    return value!.toBytes();
  }

  set oracle(value: Bytes) {
    this.set("oracle", Value.fromBytes(value));
  }

  get treasury(): Bytes {
    let value = this.get("treasury");
    return value!.toBytes();
  }

  set treasury(value: Bytes) {
    this.set("treasury", Value.fromBytes(value));
  }
}

export class StakingLimitRemove extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakingLimitRemove entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakingLimitRemove must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakingLimitRemove", id.toString(), this);
    }
  }

  static load(id: string): StakingLimitRemove | null {
    return changetype<StakingLimitRemove | null>(
      store.get("StakingLimitRemove", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class StakingLimitSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakingLimitSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakingLimitSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakingLimitSet", id.toString(), this);
    }
  }

  static load(id: string): StakingLimitSet | null {
    return changetype<StakingLimitSet | null>(store.get("StakingLimitSet", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get maxStakeLimit(): BigInt {
    let value = this.get("maxStakeLimit");
    return value!.toBigInt();
  }

  set maxStakeLimit(value: BigInt) {
    this.set("maxStakeLimit", Value.fromBigInt(value));
  }

  get stakeLimitIncreasePerBlock(): BigInt {
    let value = this.get("stakeLimitIncreasePerBlock");
    return value!.toBigInt();
  }

  set stakeLimitIncreasePerBlock(value: BigInt) {
    this.set("stakeLimitIncreasePerBlock", Value.fromBigInt(value));
  }
}

export class StakingResume extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakingResume entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakingResume must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakingResume", id.toString(), this);
    }
  }

  static load(id: string): StakingResume | null {
    return changetype<StakingResume | null>(store.get("StakingResume", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class StakingPause extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakingPause entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakingPause must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakingPause", id.toString(), this);
    }
  }

  static load(id: string): StakingPause | null {
    return changetype<StakingPause | null>(store.get("StakingPause", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class SharesTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SharesTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SharesTransfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SharesTransfer", id.toString(), this);
    }
  }

  static load(id: string): SharesTransfer | null {
    return changetype<SharesTransfer | null>(store.get("SharesTransfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get sharesValue(): BigInt {
    let value = this.get("sharesValue");
    return value!.toBigInt();
  }

  set sharesValue(value: BigInt) {
    this.set("sharesValue", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }
}

export class SharesBurn extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SharesBurn entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SharesBurn must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SharesBurn", id.toString(), this);
    }
  }

  static load(id: string): SharesBurn | null {
    return changetype<SharesBurn | null>(store.get("SharesBurn", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get postRebaseTokenAmount(): BigInt {
    let value = this.get("postRebaseTokenAmount");
    return value!.toBigInt();
  }

  set postRebaseTokenAmount(value: BigInt) {
    this.set("postRebaseTokenAmount", Value.fromBigInt(value));
  }

  get preRebaseTokenAmount(): BigInt {
    let value = this.get("preRebaseTokenAmount");
    return value!.toBigInt();
  }

  set preRebaseTokenAmount(value: BigInt) {
    this.set("preRebaseTokenAmount", Value.fromBigInt(value));
  }

  get sharesAmount(): BigInt {
    let value = this.get("sharesAmount");
    return value!.toBigInt();
  }

  set sharesAmount(value: BigInt) {
    this.set("sharesAmount", Value.fromBigInt(value));
  }
}

export class OracleCompleted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OracleCompleted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OracleCompleted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OracleCompleted", id.toString(), this);
    }
  }

  static load(id: string): OracleCompleted | null {
    return changetype<OracleCompleted | null>(store.get("OracleCompleted", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get epochId(): BigInt {
    let value = this.get("epochId");
    return value!.toBigInt();
  }

  set epochId(value: BigInt) {
    this.set("epochId", Value.fromBigInt(value));
  }

  get beaconBalance(): BigInt {
    let value = this.get("beaconBalance");
    return value!.toBigInt();
  }

  set beaconBalance(value: BigInt) {
    this.set("beaconBalance", Value.fromBigInt(value));
  }

  get beaconValidators(): BigInt {
    let value = this.get("beaconValidators");
    return value!.toBigInt();
  }

  set beaconValidators(value: BigInt) {
    this.set("beaconValidators", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class TotalReward extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TotalReward entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TotalReward must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TotalReward", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): TotalReward | null {
    return changetype<TotalReward | null>(
      store.get("TotalReward", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get totalRewards(): BigInt {
    let value = this.get("totalRewards");
    return value!.toBigInt();
  }

  set totalRewards(value: BigInt) {
    this.set("totalRewards", Value.fromBigInt(value));
  }

  get totalRewardsWithFees(): BigInt {
    let value = this.get("totalRewardsWithFees");
    return value!.toBigInt();
  }

  set totalRewardsWithFees(value: BigInt) {
    this.set("totalRewardsWithFees", Value.fromBigInt(value));
  }

  get mevFee(): BigInt | null {
    let value = this.get("mevFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set mevFee(value: BigInt | null) {
    if (!value) {
      this.unset("mevFee");
    } else {
      this.set("mevFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get feeBasis(): BigInt {
    let value = this.get("feeBasis");
    return value!.toBigInt();
  }

  set feeBasis(value: BigInt) {
    this.set("feeBasis", Value.fromBigInt(value));
  }

  get treasuryFeeBasisPoints(): BigInt {
    let value = this.get("treasuryFeeBasisPoints");
    return value!.toBigInt();
  }

  set treasuryFeeBasisPoints(value: BigInt) {
    this.set("treasuryFeeBasisPoints", Value.fromBigInt(value));
  }

  get insuranceFeeBasisPoints(): BigInt {
    let value = this.get("insuranceFeeBasisPoints");
    return value!.toBigInt();
  }

  set insuranceFeeBasisPoints(value: BigInt) {
    this.set("insuranceFeeBasisPoints", Value.fromBigInt(value));
  }

  get operatorsFeeBasisPoints(): BigInt {
    let value = this.get("operatorsFeeBasisPoints");
    return value!.toBigInt();
  }

  set operatorsFeeBasisPoints(value: BigInt) {
    this.set("operatorsFeeBasisPoints", Value.fromBigInt(value));
  }

  get totalFee(): BigInt {
    let value = this.get("totalFee");
    return value!.toBigInt();
  }

  set totalFee(value: BigInt) {
    this.set("totalFee", Value.fromBigInt(value));
  }

  get nodeOperatorFees(): Array<string> | null {
    let value = this.get("nodeOperatorFees");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set nodeOperatorFees(value: Array<string> | null) {
    if (!value) {
      this.unset("nodeOperatorFees");
    } else {
      this.set("nodeOperatorFees", Value.fromStringArray(<Array<string>>value));
    }
  }

  get insuranceFee(): BigInt | null {
    let value = this.get("insuranceFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set insuranceFee(value: BigInt | null) {
    if (!value) {
      this.unset("insuranceFee");
    } else {
      this.set("insuranceFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get operatorsFee(): BigInt {
    let value = this.get("operatorsFee");
    return value!.toBigInt();
  }

  set operatorsFee(value: BigInt) {
    this.set("operatorsFee", Value.fromBigInt(value));
  }

  get treasuryFee(): BigInt | null {
    let value = this.get("treasuryFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set treasuryFee(value: BigInt | null) {
    if (!value) {
      this.unset("treasuryFee");
    } else {
      this.set("treasuryFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get dust(): BigInt | null {
    let value = this.get("dust");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set dust(value: BigInt | null) {
    if (!value) {
      this.unset("dust");
    } else {
      this.set("dust", Value.fromBigInt(<BigInt>value));
    }
  }

  get shares2mint(): BigInt {
    let value = this.get("shares2mint");
    return value!.toBigInt();
  }

  set shares2mint(value: BigInt) {
    this.set("shares2mint", Value.fromBigInt(value));
  }

  get sharesToTreasury(): BigInt {
    let value = this.get("sharesToTreasury");
    return value!.toBigInt();
  }

  set sharesToTreasury(value: BigInt) {
    this.set("sharesToTreasury", Value.fromBigInt(value));
  }

  get sharesToInsuranceFund(): BigInt {
    let value = this.get("sharesToInsuranceFund");
    return value!.toBigInt();
  }

  set sharesToInsuranceFund(value: BigInt) {
    this.set("sharesToInsuranceFund", Value.fromBigInt(value));
  }

  get sharesToOperators(): BigInt {
    let value = this.get("sharesToOperators");
    return value!.toBigInt();
  }

  set sharesToOperators(value: BigInt) {
    this.set("sharesToOperators", Value.fromBigInt(value));
  }

  get nodeOperatorsShares(): Array<string> | null {
    let value = this.get("nodeOperatorsShares");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set nodeOperatorsShares(value: Array<string> | null) {
    if (!value) {
      this.unset("nodeOperatorsShares");
    } else {
      this.set(
        "nodeOperatorsShares",
        Value.fromStringArray(<Array<string>>value)
      );
    }
  }

  get dustSharesToTreasury(): BigInt {
    let value = this.get("dustSharesToTreasury");
    return value!.toBigInt();
  }

  set dustSharesToTreasury(value: BigInt) {
    this.set("dustSharesToTreasury", Value.fromBigInt(value));
  }

  get totalPooledEtherBefore(): BigInt {
    let value = this.get("totalPooledEtherBefore");
    return value!.toBigInt();
  }

  set totalPooledEtherBefore(value: BigInt) {
    this.set("totalPooledEtherBefore", Value.fromBigInt(value));
  }

  get totalPooledEtherAfter(): BigInt {
    let value = this.get("totalPooledEtherAfter");
    return value!.toBigInt();
  }

  set totalPooledEtherAfter(value: BigInt) {
    this.set("totalPooledEtherAfter", Value.fromBigInt(value));
  }

  get totalSharesBefore(): BigInt {
    let value = this.get("totalSharesBefore");
    return value!.toBigInt();
  }

  set totalSharesBefore(value: BigInt) {
    this.set("totalSharesBefore", Value.fromBigInt(value));
  }

  get totalSharesAfter(): BigInt {
    let value = this.get("totalSharesAfter");
    return value!.toBigInt();
  }

  set totalSharesAfter(value: BigInt) {
    this.set("totalSharesAfter", Value.fromBigInt(value));
  }

  get postTotalPooledEther(): BigInt | null {
    let value = this.get("postTotalPooledEther");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set postTotalPooledEther(value: BigInt | null) {
    if (!value) {
      this.unset("postTotalPooledEther");
    } else {
      this.set("postTotalPooledEther", Value.fromBigInt(<BigInt>value));
    }
  }

  get preTotalPooledEther(): BigInt | null {
    let value = this.get("preTotalPooledEther");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set preTotalPooledEther(value: BigInt | null) {
    if (!value) {
      this.unset("preTotalPooledEther");
    } else {
      this.set("preTotalPooledEther", Value.fromBigInt(<BigInt>value));
    }
  }

  get timeElapsed(): BigInt | null {
    let value = this.get("timeElapsed");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set timeElapsed(value: BigInt | null) {
    if (!value) {
      this.unset("timeElapsed");
    } else {
      this.set("timeElapsed", Value.fromBigInt(<BigInt>value));
    }
  }

  get totalShares(): BigInt | null {
    let value = this.get("totalShares");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set totalShares(value: BigInt | null) {
    if (!value) {
      this.unset("totalShares");
    } else {
      this.set("totalShares", Value.fromBigInt(<BigInt>value));
    }
  }

  get aprRaw(): BigDecimal {
    let value = this.get("aprRaw");
    return value!.toBigDecimal();
  }

  set aprRaw(value: BigDecimal) {
    this.set("aprRaw", Value.fromBigDecimal(value));
  }

  get aprBeforeFees(): BigDecimal | null {
    let value = this.get("aprBeforeFees");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set aprBeforeFees(value: BigDecimal | null) {
    if (!value) {
      this.unset("aprBeforeFees");
    } else {
      this.set("aprBeforeFees", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get apr(): BigDecimal {
    let value = this.get("apr");
    return value!.toBigDecimal();
  }

  set apr(value: BigDecimal) {
    this.set("apr", Value.fromBigDecimal(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionIndex(): BigInt {
    let value = this.get("transactionIndex");
    return value!.toBigInt();
  }

  set transactionIndex(value: BigInt) {
    this.set("transactionIndex", Value.fromBigInt(value));
  }

  get logIndex(): BigInt {
    let value = this.get("logIndex");
    return value!.toBigInt();
  }

  set logIndex(value: BigInt) {
    this.set("logIndex", Value.fromBigInt(value));
  }

  get transactionLogIndex(): BigInt {
    let value = this.get("transactionLogIndex");
    return value!.toBigInt();
  }

  set transactionLogIndex(value: BigInt) {
    this.set("transactionLogIndex", Value.fromBigInt(value));
  }
}

export class OracleMember extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OracleMember entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OracleMember must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OracleMember", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OracleMember | null {
    return changetype<OracleMember | null>(
      store.get("OracleMember", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get member(): Bytes {
    let value = this.get("member");
    return value!.toBytes();
  }

  set member(value: Bytes) {
    this.set("member", Value.fromBytes(value));
  }

  get removed(): boolean {
    let value = this.get("removed");
    return value!.toBoolean();
  }

  set removed(value: boolean) {
    this.set("removed", Value.fromBoolean(value));
  }
}

export class OracleQuorumChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OracleQuorumChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OracleQuorumChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OracleQuorumChange", id.toString(), this);
    }
  }

  static load(id: string): OracleQuorumChange | null {
    return changetype<OracleQuorumChange | null>(
      store.get("OracleQuorumChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get quorum(): BigInt {
    let value = this.get("quorum");
    return value!.toBigInt();
  }

  set quorum(value: BigInt) {
    this.set("quorum", Value.fromBigInt(value));
  }
}

export class OracleVersion extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OracleVersion entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OracleVersion must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OracleVersion", id.toString(), this);
    }
  }

  static load(id: string): OracleVersion | null {
    return changetype<OracleVersion | null>(store.get("OracleVersion", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): BigInt {
    let value = this.get("version");
    return value!.toBigInt();
  }

  set version(value: BigInt) {
    this.set("version", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }
}

export class AllowedBeaconBalanceRelativeDecrease extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AllowedBeaconBalanceRelativeDecrease entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AllowedBeaconBalanceRelativeDecrease must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AllowedBeaconBalanceRelativeDecrease", id.toString(), this);
    }
  }

  static load(id: string): AllowedBeaconBalanceRelativeDecrease | null {
    return changetype<AllowedBeaconBalanceRelativeDecrease | null>(
      store.get("AllowedBeaconBalanceRelativeDecrease", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class AllowedBeaconBalanceAnnualRelativeIncrease extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AllowedBeaconBalanceAnnualRelativeIncrease entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AllowedBeaconBalanceAnnualRelativeIncrease must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "AllowedBeaconBalanceAnnualRelativeIncrease",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): AllowedBeaconBalanceAnnualRelativeIncrease | null {
    return changetype<AllowedBeaconBalanceAnnualRelativeIncrease | null>(
      store.get("AllowedBeaconBalanceAnnualRelativeIncrease", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class OracleExpectedEpoch extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OracleExpectedEpoch entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OracleExpectedEpoch must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OracleExpectedEpoch", id.toString(), this);
    }
  }

  static load(id: string): OracleExpectedEpoch | null {
    return changetype<OracleExpectedEpoch | null>(
      store.get("OracleExpectedEpoch", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get epochId(): BigInt {
    let value = this.get("epochId");
    return value!.toBigInt();
  }

  set epochId(value: BigInt) {
    this.set("epochId", Value.fromBigInt(value));
  }
}

export class BeaconReport extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BeaconReport entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BeaconReport must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BeaconReport", id.toString(), this);
    }
  }

  static load(id: string): BeaconReport | null {
    return changetype<BeaconReport | null>(store.get("BeaconReport", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get epochId(): BigInt {
    let value = this.get("epochId");
    return value!.toBigInt();
  }

  set epochId(value: BigInt) {
    this.set("epochId", Value.fromBigInt(value));
  }

  get beaconBalance(): BigInt {
    let value = this.get("beaconBalance");
    return value!.toBigInt();
  }

  set beaconBalance(value: BigInt) {
    this.set("beaconBalance", Value.fromBigInt(value));
  }

  get beaconValidators(): BigInt {
    let value = this.get("beaconValidators");
    return value!.toBigInt();
  }

  set beaconValidators(value: BigInt) {
    this.set("beaconValidators", Value.fromBigInt(value));
  }

  get caller(): Bytes {
    let value = this.get("caller");
    return value!.toBytes();
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }
}

export class BeaconSpec extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BeaconSpec entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BeaconSpec must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BeaconSpec", id.toString(), this);
    }
  }

  static load(id: string): BeaconSpec | null {
    return changetype<BeaconSpec | null>(store.get("BeaconSpec", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get epochsPerFrame(): BigInt {
    let value = this.get("epochsPerFrame");
    return value!.toBigInt();
  }

  set epochsPerFrame(value: BigInt) {
    this.set("epochsPerFrame", Value.fromBigInt(value));
  }

  get slotsPerEpoch(): BigInt {
    let value = this.get("slotsPerEpoch");
    return value!.toBigInt();
  }

  set slotsPerEpoch(value: BigInt) {
    this.set("slotsPerEpoch", Value.fromBigInt(value));
  }

  get secondsPerSlot(): BigInt {
    let value = this.get("secondsPerSlot");
    return value!.toBigInt();
  }

  set secondsPerSlot(value: BigInt) {
    this.set("secondsPerSlot", Value.fromBigInt(value));
  }

  get genesisTime(): BigInt {
    let value = this.get("genesisTime");
    return value!.toBigInt();
  }

  set genesisTime(value: BigInt) {
    this.set("genesisTime", Value.fromBigInt(value));
  }
}

export class BeaconReportReceiver extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BeaconReportReceiver entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BeaconReportReceiver must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BeaconReportReceiver", id.toString(), this);
    }
  }

  static load(id: string): BeaconReportReceiver | null {
    return changetype<BeaconReportReceiver | null>(
      store.get("BeaconReportReceiver", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get callback(): Bytes {
    let value = this.get("callback");
    return value!.toBytes();
  }

  set callback(value: Bytes) {
    this.set("callback", Value.fromBytes(value));
  }
}

export class NodeOperatorSigningKey extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NodeOperatorSigningKey entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type NodeOperatorSigningKey must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NodeOperatorSigningKey", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): NodeOperatorSigningKey | null {
    return changetype<NodeOperatorSigningKey | null>(
      store.get("NodeOperatorSigningKey", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get operatorId(): BigInt {
    let value = this.get("operatorId");
    return value!.toBigInt();
  }

  set operatorId(value: BigInt) {
    this.set("operatorId", Value.fromBigInt(value));
  }

  get pubkey(): Bytes {
    let value = this.get("pubkey");
    return value!.toBytes();
  }

  set pubkey(value: Bytes) {
    this.set("pubkey", Value.fromBytes(value));
  }

  get removed(): boolean {
    let value = this.get("removed");
    return value!.toBoolean();
  }

  set removed(value: boolean) {
    this.set("removed", Value.fromBoolean(value));
  }

  get operator(): string {
    let value = this.get("operator");
    return value!.toString();
  }

  set operator(value: string) {
    this.set("operator", Value.fromString(value));
  }
}

export class NodeOperator extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NodeOperator entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NodeOperator must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NodeOperator", id.toString(), this);
    }
  }

  static load(id: string): NodeOperator | null {
    return changetype<NodeOperator | null>(store.get("NodeOperator", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get rewardAddress(): Bytes {
    let value = this.get("rewardAddress");
    return value!.toBytes();
  }

  set rewardAddress(value: Bytes) {
    this.set("rewardAddress", Value.fromBytes(value));
  }

  get stakingLimit(): BigInt {
    let value = this.get("stakingLimit");
    return value!.toBigInt();
  }

  set stakingLimit(value: BigInt) {
    this.set("stakingLimit", Value.fromBigInt(value));
  }

  get active(): boolean {
    let value = this.get("active");
    return value!.toBoolean();
  }

  set active(value: boolean) {
    this.set("active", Value.fromBoolean(value));
  }

  get totalStoppedValidators(): BigInt | null {
    let value = this.get("totalStoppedValidators");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set totalStoppedValidators(value: BigInt | null) {
    if (!value) {
      this.unset("totalStoppedValidators");
    } else {
      this.set("totalStoppedValidators", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class NodeOperatorTotalKeysTrim extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NodeOperatorTotalKeysTrim entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NodeOperatorTotalKeysTrim must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NodeOperatorTotalKeysTrim", id.toString(), this);
    }
  }

  static load(id: string): NodeOperatorTotalKeysTrim | null {
    return changetype<NodeOperatorTotalKeysTrim | null>(
      store.get("NodeOperatorTotalKeysTrim", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get operatorId(): BigInt {
    let value = this.get("operatorId");
    return value!.toBigInt();
  }

  set operatorId(value: BigInt) {
    this.set("operatorId", Value.fromBigInt(value));
  }

  get totalKeysTrimmed(): BigInt {
    let value = this.get("totalKeysTrimmed");
    return value!.toBigInt();
  }

  set totalKeysTrimmed(value: BigInt) {
    this.set("totalKeysTrimmed", Value.fromBigInt(value));
  }

  get operator(): string {
    let value = this.get("operator");
    return value!.toString();
  }

  set operator(value: string) {
    this.set("operator", Value.fromString(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }
}

export class handleKeysOpIndexChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save handleKeysOpIndexChange entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type handleKeysOpIndexChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("handleKeysOpIndexChange", id.toString(), this);
    }
  }

  static load(id: string): handleKeysOpIndexChange | null {
    return changetype<handleKeysOpIndexChange | null>(
      store.get("handleKeysOpIndexChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }
}

export class Voting extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Voting entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Voting must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Voting", id.toString(), this);
    }
  }

  static load(id: string): Voting | null {
    return changetype<Voting | null>(store.get("Voting", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get index(): i32 {
    let value = this.get("index");
    return value!.toI32();
  }

  set index(value: i32) {
    this.set("index", Value.fromI32(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value!.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get metadata(): string {
    let value = this.get("metadata");
    return value!.toString();
  }

  set metadata(value: string) {
    this.set("metadata", Value.fromString(value));
  }

  get executed(): boolean {
    let value = this.get("executed");
    return value!.toBoolean();
  }

  set executed(value: boolean) {
    this.set("executed", Value.fromBoolean(value));
  }

  get votes(): Array<string> {
    let value = this.get("votes");
    return value!.toStringArray();
  }

  set votes(value: Array<string>) {
    this.set("votes", Value.fromStringArray(value));
  }

  get objections(): Array<string> {
    let value = this.get("objections");
    return value!.toStringArray();
  }

  set objections(value: Array<string>) {
    this.set("objections", Value.fromStringArray(value));
  }
}

export class Vote extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Vote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Vote must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Vote", id.toString(), this);
    }
  }

  static load(id: string): Vote | null {
    return changetype<Vote | null>(store.get("Vote", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get voting(): string {
    let value = this.get("voting");
    return value!.toString();
  }

  set voting(value: string) {
    this.set("voting", Value.fromString(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    return value!.toBytes();
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get supports(): boolean {
    let value = this.get("supports");
    return value!.toBoolean();
  }

  set supports(value: boolean) {
    this.set("supports", Value.fromBoolean(value));
  }

  get stake(): BigInt {
    let value = this.get("stake");
    return value!.toBigInt();
  }

  set stake(value: BigInt) {
    this.set("stake", Value.fromBigInt(value));
  }
}

export class VotingObjection extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VotingObjection entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VotingObjection must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VotingObjection", id.toString(), this);
    }
  }

  static load(id: string): VotingObjection | null {
    return changetype<VotingObjection | null>(store.get("VotingObjection", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get voting(): string {
    let value = this.get("voting");
    return value!.toString();
  }

  set voting(value: string) {
    this.set("voting", Value.fromString(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    return value!.toBytes();
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get stake(): BigInt {
    let value = this.get("stake");
    return value!.toBigInt();
  }

  set stake(value: BigInt) {
    this.set("stake", Value.fromBigInt(value));
  }
}

export class ChangedSupportRequired extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ChangedSupportRequired entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChangedSupportRequired must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangedSupportRequired", id.toString(), this);
    }
  }

  static load(id: string): ChangedSupportRequired | null {
    return changetype<ChangedSupportRequired | null>(
      store.get("ChangedSupportRequired", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get supportRequiredPct(): BigInt {
    let value = this.get("supportRequiredPct");
    return value!.toBigInt();
  }

  set supportRequiredPct(value: BigInt) {
    this.set("supportRequiredPct", Value.fromBigInt(value));
  }
}

export class ChangedMinQuorum extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ChangedMinQuorum entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChangedMinQuorum must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangedMinQuorum", id.toString(), this);
    }
  }

  static load(id: string): ChangedMinQuorum | null {
    return changetype<ChangedMinQuorum | null>(
      store.get("ChangedMinQuorum", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get minAcceptQuorumPct(): BigInt {
    let value = this.get("minAcceptQuorumPct");
    return value!.toBigInt();
  }

  set minAcceptQuorumPct(value: BigInt) {
    this.set("minAcceptQuorumPct", Value.fromBigInt(value));
  }
}

export class ChangedVoteTime extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ChangedVoteTime entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChangedVoteTime must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangedVoteTime", id.toString(), this);
    }
  }

  static load(id: string): ChangedVoteTime | null {
    return changetype<ChangedVoteTime | null>(store.get("ChangedVoteTime", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get voteTime(): BigInt {
    let value = this.get("voteTime");
    return value!.toBigInt();
  }

  set voteTime(value: BigInt) {
    this.set("voteTime", Value.fromBigInt(value));
  }
}

export class ChangedObjectionPhaseTime extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ChangedObjectionPhaseTime entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChangedObjectionPhaseTime must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangedObjectionPhaseTime", id.toString(), this);
    }
  }

  static load(id: string): ChangedObjectionPhaseTime | null {
    return changetype<ChangedObjectionPhaseTime | null>(
      store.get("ChangedObjectionPhaseTime", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get objectionPhaseTime(): BigInt {
    let value = this.get("objectionPhaseTime");
    return value!.toBigInt();
  }

  set objectionPhaseTime(value: BigInt) {
    this.set("objectionPhaseTime", Value.fromBigInt(value));
  }
}

export class Motion extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Motion entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Motion must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Motion", id.toString(), this);
    }
  }

  static load(id: string): Motion | null {
    return changetype<Motion | null>(store.get("Motion", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value!.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get evmScriptFactory(): Bytes {
    let value = this.get("evmScriptFactory");
    return value!.toBytes();
  }

  set evmScriptFactory(value: Bytes) {
    this.set("evmScriptFactory", Value.fromBytes(value));
  }

  get duration(): BigInt | null {
    let value = this.get("duration");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set duration(value: BigInt | null) {
    if (!value) {
      this.unset("duration");
    } else {
      this.set("duration", Value.fromBigInt(<BigInt>value));
    }
  }

  get startDate(): BigInt {
    let value = this.get("startDate");
    return value!.toBigInt();
  }

  set startDate(value: BigInt) {
    this.set("startDate", Value.fromBigInt(value));
  }

  get snapshotBlock(): BigInt {
    let value = this.get("snapshotBlock");
    return value!.toBigInt();
  }

  set snapshotBlock(value: BigInt) {
    this.set("snapshotBlock", Value.fromBigInt(value));
  }

  get objectionsAmount(): BigInt {
    let value = this.get("objectionsAmount");
    return value!.toBigInt();
  }

  set objectionsAmount(value: BigInt) {
    this.set("objectionsAmount", Value.fromBigInt(value));
  }

  get objectionsAmountPct(): BigInt {
    let value = this.get("objectionsAmountPct");
    return value!.toBigInt();
  }

  set objectionsAmountPct(value: BigInt) {
    this.set("objectionsAmountPct", Value.fromBigInt(value));
  }

  get objectionsThreshold(): BigInt | null {
    let value = this.get("objectionsThreshold");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set objectionsThreshold(value: BigInt | null) {
    if (!value) {
      this.unset("objectionsThreshold");
    } else {
      this.set("objectionsThreshold", Value.fromBigInt(<BigInt>value));
    }
  }

  get evmScriptHash(): Bytes {
    let value = this.get("evmScriptHash");
    return value!.toBytes();
  }

  set evmScriptHash(value: Bytes) {
    this.set("evmScriptHash", Value.fromBytes(value));
  }

  get evmScriptCalldata(): Bytes {
    let value = this.get("evmScriptCalldata");
    return value!.toBytes();
  }

  set evmScriptCalldata(value: Bytes) {
    this.set("evmScriptCalldata", Value.fromBytes(value));
  }

  get status(): string {
    let value = this.get("status");
    return value!.toString();
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get enacted_at(): BigInt | null {
    let value = this.get("enacted_at");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set enacted_at(value: BigInt | null) {
    if (!value) {
      this.unset("enacted_at");
    } else {
      this.set("enacted_at", Value.fromBigInt(<BigInt>value));
    }
  }

  get canceled_at(): BigInt | null {
    let value = this.get("canceled_at");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set canceled_at(value: BigInt | null) {
    if (!value) {
      this.unset("canceled_at");
    } else {
      this.set("canceled_at", Value.fromBigInt(<BigInt>value));
    }
  }

  get rejected_at(): BigInt | null {
    let value = this.get("rejected_at");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set rejected_at(value: BigInt | null) {
    if (!value) {
      this.unset("rejected_at");
    } else {
      this.set("rejected_at", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class EasyTrackConfig extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EasyTrackConfig entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EasyTrackConfig must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EasyTrackConfig", id.toString(), this);
    }
  }

  static load(id: string): EasyTrackConfig | null {
    return changetype<EasyTrackConfig | null>(store.get("EasyTrackConfig", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get evmScriptExecutor(): Bytes | null {
    let value = this.get("evmScriptExecutor");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set evmScriptExecutor(value: Bytes | null) {
    if (!value) {
      this.unset("evmScriptExecutor");
    } else {
      this.set("evmScriptExecutor", Value.fromBytes(<Bytes>value));
    }
  }

  get motionDuration(): BigInt | null {
    let value = this.get("motionDuration");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set motionDuration(value: BigInt | null) {
    if (!value) {
      this.unset("motionDuration");
    } else {
      this.set("motionDuration", Value.fromBigInt(<BigInt>value));
    }
  }

  get motionsCountLimit(): BigInt | null {
    let value = this.get("motionsCountLimit");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set motionsCountLimit(value: BigInt | null) {
    if (!value) {
      this.unset("motionsCountLimit");
    } else {
      this.set("motionsCountLimit", Value.fromBigInt(<BigInt>value));
    }
  }

  get objectionsThreshold(): BigInt | null {
    let value = this.get("objectionsThreshold");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set objectionsThreshold(value: BigInt | null) {
    if (!value) {
      this.unset("objectionsThreshold");
    } else {
      this.set("objectionsThreshold", Value.fromBigInt(<BigInt>value));
    }
  }

  get isPaused(): boolean {
    let value = this.get("isPaused");
    return value!.toBoolean();
  }

  set isPaused(value: boolean) {
    this.set("isPaused", Value.fromBoolean(value));
  }
}

export class Role extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Role entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Role must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Role", id.toString(), this);
    }
  }

  static load(id: string): Role | null {
    return changetype<Role | null>(store.get("Role", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value!.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get isActive(): boolean {
    let value = this.get("isActive");
    return value!.toBoolean();
  }

  set isActive(value: boolean) {
    this.set("isActive", Value.fromBoolean(value));
  }
}

export class EVMScriptFactory extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EVMScriptFactory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EVMScriptFactory must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EVMScriptFactory", id.toString(), this);
    }
  }

  static load(id: string): EVMScriptFactory | null {
    return changetype<EVMScriptFactory | null>(
      store.get("EVMScriptFactory", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get permissions(): Bytes {
    let value = this.get("permissions");
    return value!.toBytes();
  }

  set permissions(value: Bytes) {
    this.set("permissions", Value.fromBytes(value));
  }

  get isActive(): boolean {
    let value = this.get("isActive");
    return value!.toBoolean();
  }

  set isActive(value: boolean) {
    this.set("isActive", Value.fromBoolean(value));
  }
}

export class Objection extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Objection entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Objection must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Objection", id.toString(), this);
    }
  }

  static load(id: string): Objection | null {
    return changetype<Objection | null>(store.get("Objection", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get motionId(): BigInt {
    let value = this.get("motionId");
    return value!.toBigInt();
  }

  set motionId(value: BigInt) {
    this.set("motionId", Value.fromBigInt(value));
  }

  get objector(): Bytes {
    let value = this.get("objector");
    return value!.toBytes();
  }

  set objector(value: Bytes) {
    this.set("objector", Value.fromBytes(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    return value!.toBigInt();
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }
}

export class DepositSecurityModuleSettings extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DepositSecurityModuleSettings entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DepositSecurityModuleSettings must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DepositSecurityModuleSettings", id.toString(), this);
    }
  }

  static load(id: string): DepositSecurityModuleSettings | null {
    return changetype<DepositSecurityModuleSettings | null>(
      store.get("DepositSecurityModuleSettings", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get paused(): boolean {
    let value = this.get("paused");
    return value!.toBoolean();
  }

  set paused(value: boolean) {
    this.set("paused", Value.fromBoolean(value));
  }

  get guardianQuorum(): BigInt | null {
    let value = this.get("guardianQuorum");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set guardianQuorum(value: BigInt | null) {
    if (!value) {
      this.unset("guardianQuorum");
    } else {
      this.set("guardianQuorum", Value.fromBigInt(<BigInt>value));
    }
  }

  get maxDeposits(): BigInt | null {
    let value = this.get("maxDeposits");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set maxDeposits(value: BigInt | null) {
    if (!value) {
      this.unset("maxDeposits");
    } else {
      this.set("maxDeposits", Value.fromBigInt(<BigInt>value));
    }
  }

  get minDepositBlockDistance(): BigInt | null {
    let value = this.get("minDepositBlockDistance");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set minDepositBlockDistance(value: BigInt | null) {
    if (!value) {
      this.unset("minDepositBlockDistance");
    } else {
      this.set("minDepositBlockDistance", Value.fromBigInt(<BigInt>value));
    }
  }

  get nodeOperatorsRegistry(): Bytes | null {
    let value = this.get("nodeOperatorsRegistry");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set nodeOperatorsRegistry(value: Bytes | null) {
    if (!value) {
      this.unset("nodeOperatorsRegistry");
    } else {
      this.set("nodeOperatorsRegistry", Value.fromBytes(<Bytes>value));
    }
  }

  get owner(): Bytes | null {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes | null) {
    if (!value) {
      this.unset("owner");
    } else {
      this.set("owner", Value.fromBytes(<Bytes>value));
    }
  }

  get pauseIntentValidityPeriodBlocks(): BigInt | null {
    let value = this.get("pauseIntentValidityPeriodBlocks");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set pauseIntentValidityPeriodBlocks(value: BigInt | null) {
    if (!value) {
      this.unset("pauseIntentValidityPeriodBlocks");
    } else {
      this.set(
        "pauseIntentValidityPeriodBlocks",
        Value.fromBigInt(<BigInt>value)
      );
    }
  }
}

export class DepositsPause extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DepositsPause entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DepositsPause must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DepositsPause", id.toString(), this);
    }
  }

  static load(id: string): DepositsPause | null {
    return changetype<DepositsPause | null>(store.get("DepositsPause", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get guardian(): string {
    let value = this.get("guardian");
    return value!.toString();
  }

  set guardian(value: string) {
    this.set("guardian", Value.fromString(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DepositsUnpause extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DepositsUnpause entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DepositsUnpause must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DepositsUnpause", id.toString(), this);
    }
  }

  static load(id: string): DepositsUnpause | null {
    return changetype<DepositsUnpause | null>(store.get("DepositsUnpause", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Guardian extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Guardian entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Guardian must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Guardian", id.toString(), this);
    }
  }

  static load(id: string): Guardian | null {
    return changetype<Guardian | null>(store.get("Guardian", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get removed(): boolean {
    let value = this.get("removed");
    return value!.toBoolean();
  }

  set removed(value: boolean) {
    this.set("removed", Value.fromBoolean(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GuardianQuorumChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GuardianQuorumChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GuardianQuorumChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GuardianQuorumChange", id.toString(), this);
    }
  }

  static load(id: string): GuardianQuorumChange | null {
    return changetype<GuardianQuorumChange | null>(
      store.get("GuardianQuorumChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get guardianQuorum(): BigInt {
    let value = this.get("guardianQuorum");
    return value!.toBigInt();
  }

  set guardianQuorum(value: BigInt) {
    this.set("guardianQuorum", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class MaxDepositsChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MaxDepositsChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MaxDepositsChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MaxDepositsChange", id.toString(), this);
    }
  }

  static load(id: string): MaxDepositsChange | null {
    return changetype<MaxDepositsChange | null>(
      store.get("MaxDepositsChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get maxDeposits(): BigInt {
    let value = this.get("maxDeposits");
    return value!.toBigInt();
  }

  set maxDeposits(value: BigInt) {
    this.set("maxDeposits", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class MinDepositBlockDistanceChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save MinDepositBlockDistanceChange entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MinDepositBlockDistanceChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MinDepositBlockDistanceChange", id.toString(), this);
    }
  }

  static load(id: string): MinDepositBlockDistanceChange | null {
    return changetype<MinDepositBlockDistanceChange | null>(
      store.get("MinDepositBlockDistanceChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get minDepositBlockDistance(): BigInt {
    let value = this.get("minDepositBlockDistance");
    return value!.toBigInt();
  }

  set minDepositBlockDistance(value: BigInt) {
    this.set("minDepositBlockDistance", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NodeOperatorsRegistryChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NodeOperatorsRegistryChange entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NodeOperatorsRegistryChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NodeOperatorsRegistryChange", id.toString(), this);
    }
  }

  static load(id: string): NodeOperatorsRegistryChange | null {
    return changetype<NodeOperatorsRegistryChange | null>(
      store.get("NodeOperatorsRegistryChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get nodeOperatorsRegistry(): Bytes {
    let value = this.get("nodeOperatorsRegistry");
    return value!.toBytes();
  }

  set nodeOperatorsRegistry(value: Bytes) {
    this.set("nodeOperatorsRegistry", Value.fromBytes(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OwnerChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnerChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OwnerChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnerChange", id.toString(), this);
    }
  }

  static load(id: string): OwnerChange | null {
    return changetype<OwnerChange | null>(store.get("OwnerChange", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PauseIntentValidityPeriodBlocksChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save PauseIntentValidityPeriodBlocksChange entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PauseIntentValidityPeriodBlocksChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PauseIntentValidityPeriodBlocksChange", id.toString(), this);
    }
  }

  static load(id: string): PauseIntentValidityPeriodBlocksChange | null {
    return changetype<PauseIntentValidityPeriodBlocksChange | null>(
      store.get("PauseIntentValidityPeriodBlocksChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pauseIntentValidityPeriodBlocks(): BigInt {
    let value = this.get("pauseIntentValidityPeriodBlocks");
    return value!.toBigInt();
  }

  set pauseIntentValidityPeriodBlocks(value: BigInt) {
    this.set("pauseIntentValidityPeriodBlocks", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get blockTime(): BigInt {
    let value = this.get("blockTime");
    return value!.toBigInt();
  }

  set blockTime(value: BigInt) {
    this.set("blockTime", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}
